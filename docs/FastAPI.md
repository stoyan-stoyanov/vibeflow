# Using Vibeflow with FastAPI

Vibeflow is a great fit for `async` web frameworks like FastAPI. For example, you can use the `@vibe` decorator to generate the logic for your API endpoints on the fly, keeping your route definitions clean and focused on the API structure.

## FastAPI Example

In this example, the `@vibe` decorator is placed *after* FastAPI's route decorator (`@app.get`). This order is important: it ensures that FastAPI registers the route correctly, and then Vibeflow replaces the function's implementation with AI-generated code.

### Example: `fastapi_app.py`

```python
from fastapi import FastAPI
from vibeflow import vibe

app = FastAPI()

@app.get("/generate_text")
@vibe
async def generate_text(topic: str) -> dict:
    """Generate a short, two-sentence paragraph about the given topic."""
    ... # The implementation will be generated by vibe

@app.get("/")
async def read_root():
    return {"message": "Welcome to the Vibe-powered FastAPI app! Visit /docs for API details."}
```

### How It Works

1.  **FastAPI Registers the Route**: FastAPI sees `@app.get("/generate_text")` and registers the `generate_text` function as the handler for that endpoint.
2.  **Vibeflow Generates the Code**: The `@vibe` decorator then runs, replacing the stub implementation (`...`) with a fully functional async function body based on the docstring.
3.  **Requests are Served**: When a request hits the `/generate_text` endpoint, FastAPI calls the now-complete `generate_text` function, which is then executed and awaited, returning the AI-generated response.
